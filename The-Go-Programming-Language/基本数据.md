**第三章：基本数据类型 总结**

Go 语言的基础数据类型包括：

1. **整数 (Integers):**

   * **有符号整数:** `int8`, `int16`, `int32`, `int64`, `int`
     * `int` 的大小取决于平台（32 位或 64 位）。
   * **无符号整数:** `uint8`, `uint16`, `uint32`, `uint64`, `uint`
     * `uint` 的大小取决于平台。
   * **`rune`:** 与 `int32` 等价，表示一个 Unicode 码点。
   * **`byte`:** 与 `uint8` 等价，通常用于表示原始字节数据。
   * **`uintptr`:** 无符号整数，用于存储指针的值（底层编程）。
   * 无类型整数常量：编译器根据上下文推断类型.
   * **运算符:** 算术运算符（`+`、`-`、`*`、`/`、`%`）、比较运算符（`==`、`!=`、`<`、`<=`、`>`、`>=`）、位运算符（`&`、`|`、`^`、`&^`、`<<`、`>>`）等。
   * **注意溢出问题。**
2. **浮点数 (Floating-Point Numbers):**

   * **`float32`:** IEEE-754 32 位浮点数。
   * **`float64`:** IEEE-754 64 位浮点数（更常用）。
   * **字面量表示:** 十进制表示（`3.14`）、科学记数法（`1.23e-4`）。
   * **`math` 包:** 提供了常用的数学函数（`math.Sin`, `math.Cos`, `math.Sqrt` 等）。
   * **特殊值:** `NaN` (Not a Number)、`Inf` (无穷大)、`-Inf` (负无穷大)。
   * **注意精度和舍入误差。**
3. **复数 (Complex Numbers):**

   * **`complex64`:** 实部和虚部都是 `float32`。
   * **`complex128`:** 实部和虚部都是 `float64`（更常用）。
   * **字面量表示:** `1 + 2i`、`2i`。
   * **`real()` 和 `imag()` 函数:** 分别获取复数的实部和虚部。
   * **`complex()` 函数:** 通过实部和虚部创建复数。
4. **布尔值 (Booleans):**

   * **`bool`:** 取值为 `true` 或 `false`。
   * **逻辑运算符:** `&&` (与)、`||` (或)、`!` (非)。
   * **短路求值:** `&&` 和 `||` 具有短路行为。
5. **字符串 (Strings):**

   * **本质:** 不可变的字节序列（通常是 UTF-8 编码）。
   * **字面量表示:** 双引号 (`"hello"`) 或反引号 (```raw string```)。
   * **转义字符:** `\n`、`\t`、`\"` 等。
   * **`len()` 函数:** 获取字符串的字节长度（不是字符数）。
   * **索引:** `s[i]` 访问第 i 个字节（不是第 i 个字符）。
   * **切片:** `s[i:j]` 获取子串。
   * **拼接:** `+` 运算符（效率较低），`strings.Builder` 或 `bytes.Buffer`（效率较高）。
   * **不可变性:** 字符串的内容不能修改。
   * **`strings` 包:** 提供了常用的字符串操作函数。
   * **`strconv` 包:** 字符串与其他类型之间的转换。
   * **Unicode:** Go 支持 Unicode 字符和 UTF-8 编码。
     * `unicode/utf8`包提供了用于处理utf-8编码的函数。
6. **常量(Constants)**

   * 使用`const`关键字声明
   * 常量的值在编译期确定
   * 可以是布尔值、字符串、数字（整数、浮点数、复数）
   * 无类型常量：没有明确的基础类型，可以参与多种类型的运算

**测试题 (选择题 + 简答题):**

**选择题 (每题 2 分，共 20 分):**

1. 以下哪个不是 Go 语言的整数类型？ c
   A. `int32`
   B. `uint`
   C. `float32`
   D. `int`
2. `rune` 类型等价于以下哪个类型？c
   A. `int8`
   B. `uint8`
   C. `int32`
   D. `uint32`
3. 以下哪个是 Go 语言中表示复数的类型？b
   A. `float64`
   B. `complex128`
   C. `int64`
   D. `string`
4. 在 Go 语言中，字符串的拼接最高效的方式是什么？c
   A. 使用 `+` 运算符
   B. 使用 `fmt.Sprintf`
   C. 使用 `strings.Builder` 或 `bytes.Buffer`
   D. 使用 `append` 函数
5. 以下哪个关于 Go 字符串的说法是错误的？ c
   A. 字符串是不可变的
   B. `len(s)` 返回字符串 `s` 的字节长度
   C. `s[i]` 访问字符串 `s` 的第 `i` 个字符
   D. 字符串可以使用双引号或反引号表示
6. 以下哪个是有效的 Go 字符串字面量？b
   A. `'hello'`
   B. `"hello\nworld"`
   C. `\`hello\`
   D. `(hello)`
7. 以下哪个是 Go 语言中表示无穷大的常量？b
   A. `NaN`
   B. `Inf`
   C. `Max`
   D. `Zero`
8. 以下哪个运算符具有短路求值行为？c
   A. `+`
   B. `&`
   C. `||`
   D. `*`
9. 以下哪个包提供了字符串和其他类型之间转换的函数？b
   A. `strings`
   B. `strconv`
   C. `math`
   D. `unicode`
10. 以下哪个关于常量的说法是正确的?d
    A.  常量声明必须显式指定类型
    B.  常量的值可以在运行时修改
    C.  常量可以是函数
    D.  无类型常量可以参与多种类型的运算

**简答题 (每题 10 分，共 30 分):**

1. 请解释 Go 语言中 `int` 和 `int64` 的区别，以及为什么 Go 同时提供了这两种类型。
2. 请解释什么是 UTF-8 编码，以及它与 Unicode 的关系。为什么 Go 语言选择使用 UTF-8？
3. 请解释无类型常量和有类型常量的区别，并给出一个使用无类型常量的例子。

**答案：**

**选择题：**

1. C
2. C
3. B
4. C
5. C
6. B
7. B
8. C
9. B
10. D

**简答题：**

1. **`int` 和 `int64` 的区别：**

   * `int` 是一个有符号整数类型，它的大小取决于底层平台（可能是 32 位或 64 位）。
   * `int64` 是一个有符号整数类型，它的大小固定为 64 位。
   * Go 同时提供这两种类型是为了：
     * **灵活性：** `int` 类型允许程序员编写在不同平台上都能工作的代码，而无需关心底层整数的大小。
     * **控制：** `int64` 类型允许程序员精确控制整数的大小，这在需要特定大小的整数（例如，与 C 代码交互或进行位操作）时非常有用。
2. **UTF-8 和 Unicode:**

   * **Unicode:** 是一个字符集，它为世界上几乎所有的字符分配了一个唯一的数字（码点）。
   * **UTF-8:** 是一种针对 Unicode 的可变长度字符编码。它将 Unicode 码点编码为一个或多个字节。
     * ASCII 字符使用 1 个字节。
     * 常用的字符（如大多数拉丁字母）使用 2 个字节。
     * CJK 字符（中文、日文、韩文）通常使用 3 个字节。
     * 罕见字符或表情符号使用 4 个字节。
   * **关系：** UTF-8 是 Unicode 的一种实现方式。
   * **Go 选择 UTF-8 的原因：**
     * **兼容性：** 与 ASCII 兼容。
     * **效率：** 对于英文文本，UTF-8 非常节省空间（因为 ASCII 字符只占用 1 个字节）。
     * **通用性：** 可以表示所有 Unicode 字符。
     * **广泛采用：** 是互联网上最常用的字符编码。
3. **无类型常量和有类型常量的区别:**

   * **无类型常量:** 没有明确的基础类型。编译器会根据上下文推断其类型。
     ```go
     const a = 100 // 无类型整数
     const b = 3.14 // 无类型浮点数
     const c = "hello" // 无类型字符串
     ```
   * 可以参与多种类型的运算
   * **有类型常量:** 具有明确的基础类型。
     ```go
     const x int = 100
     const y float64 = 3.14
     const z string = "hello"
     ```
   * 只能参与同类型运算,或者显式类型转换后的运算.

   **例子(无类型常量):**

   ```go
      const PI = 3.14159
      var radius float32 = 5.0
      var area = PI * radius * radius // PI 会被推断为 float32
      fmt.Println(area)
   ```

   在此示例中，`PI` 是一个无类型浮点常量。在与 `float32` 类型的变量 `radius` 进行运算时，`PI` 会被隐式地视为 `float32` 类型。如果 `PI` 被定义为有类型的 `float64` 常量，则需要显式类型转换。


### for interview Q&A

**1. 字符串 (Strings) 相关：**

*   **字符串的不可变性 (Immutability):**
    *   理解为什么 Go 字符串是不可变的。
    *   知道这意味着什么：每次修改字符串（例如拼接）都会创建一个新的字符串对象。
    *   了解如何高效地构建字符串（`strings.Builder` 或 `bytes.Buffer`）。
        * 分配新的内存空间
        * 将现有字符串的内容复制到新内存
        * 旧的字符串对象变成垃圾，等待垃圾回收
    *   面试题示例：
        *   “Go 语言中的字符串可以修改吗？为什么？”
        *   “如何高效地拼接大量的字符串？”
        *   "`s[i] = 'a'` 这行代码有什么问题？" (假设 `s` 是一个字符串)

*   **字符串和字节切片 (`[]byte`) 的关系：**
    *   知道字符串底层是一个字节数组。
    *   理解字符串和字节切片之间的转换：
        *   `string([]byte{...})`
        *   `[]byte("hello")`
    *   了解何时需要进行转换（例如，当你需要修改字符串内容时）。
    *   面试题示例：
        *   “如何在 Go 中修改字符串中的某个字符？”
        *   “`string` 和 `[]byte` 有什么区别？何时应该使用哪一个？”
        *   "比较 `strings.Builder` 和 `bytes.Buffer` 在字符串构建方面的异同。"

*   **Unicode 和 UTF-8：**
    *   理解 Unicode 和 UTF-8 的基本概念。
    *   知道 Go 字符串使用 UTF-8 编码。
    *   了解 `len()` 函数返回的是字节长度，而不是字符数。
    *   知道如何获取字符串的字符数 (rune count)：`utf8.RuneCountInString()` 或转换为 `[]rune`。
    *   知道如何遍历字符串中的每个字符 (rune)：使用 `range` 循环。
    *   面试题示例：
        *   “Go 语言如何处理 Unicode 字符？”
        *   “`len("你好世界")` 的返回值是什么？为什么？”
        *   “如何遍历一个字符串中的每个 Unicode 字符？”
        *   "解释一下什么是 rune？"

*   **字符串相关的标准库：**
    *   熟悉 `strings` 包中常用的函数：`Contains`, `HasPrefix`, `HasSuffix`, `Index`, `Join`, `Replace`, `Split`, `ToLower`, `ToUpper`, `TrimSpace` 等。
    *   熟悉 `strconv` 包中常用的函数：`Atoi`, `Itoa`, `ParseBool`, `ParseFloat`, `ParseInt`, `FormatBool`, `FormatFloat`, `FormatInt` 等。

**2. 数值类型相关：**

*   **类型转换：**
    *   理解 Go 是一种强类型语言，不同类型之间通常需要显式转换。
    *   知道如何进行类型转换（例如 `int(3.14)`, `float64(10)`, `string(65)`）。
    *   了解类型转换可能带来的风险（例如，截断、溢出）。
    *   面试题示例:
        *   "在 Go 中，如何将一个 `float64` 转换为 `int`？需要注意什么？" 分情况回答，不同情况对应的结果不同；
            * 普通转换，会发生截断，例如 3.14 = > 3
            * 如果float64较大，超出了int的可以表示范围，会发生溢出
            * 如果为float64为 NaN，会变为0，如果 inf hui
        *   "将一个较大的 `int64` 值转换为 `int32` 可能会发生什么？"
            * 溢出，该数超出了int32所表示的大小范围；

*   **无类型常量 (Untyped Constants):**
    *   理解无类型常量的概念和优势。
    *   知道无类型常量可以参与不同类型的运算，编译器会自动进行类型推断或转换。
    *   了解无类型常量的默认类型（例如，`123` 的默认类型是 `int`，`3.14` 的默认类型是 `float64`）。
    *   面试题示例：
        *   “什么是无类型常量？它有什么好处？”
        *   "以下代码的输出是什么？为什么？`const a = 10; var b float32 = a; fmt.Println(b)`"

*   **溢出：**
    *   理解整数溢出的概念。
    *   知道如何检测溢出（虽然 Go 没有内置的溢出检测机制，但你可以手动检查）。
    *   面试题示例：
        *   “什么是整数溢出？在 Go 中如何处理？”

*   **浮点数精度：**
    *   了解浮点数 (特别是 `float32`) 的精度限制。
    *   知道如何比较浮点数（不能直接用 `==`，应该使用一个很小的误差范围）。
    *   了解`math.Nextafter`的使用
    *   面试题示例：
        *   “为什么 `0.1 + 0.2 != 0.3`？在 Go 中如何比较浮点数？”

**3. 其他：**
*  **iota的使用:** 理解iota的用法和特性。
*   **零值 (Zero Values):** 了解不同类型变量的默认零值（例如，`int` 的零值是 0，`string` 的零值是 `""`，`bool` 的零值是 `false`）。

**为什么这些是热点？**

*   **基础但重要：** 这些概念是 Go 语言的基础，但它们对于编写正确、高效、健壮的代码至关重要。
*   **容易出错：** 这些知识点涉及到底层细节（如内存表示、编码、精度），容易被忽略或误解，导致程序出现 bug。
*   **考察理解深度：** 面试官可以通过这些问题来考察你对 Go 语言的理解深度，以及你是否注重细节。