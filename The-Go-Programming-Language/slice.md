## Slice

### 基础知识

**Go 语言 Slice 实现原理及核心知识点**

1.  **切片 (Slice) 的定义:**

    *   切片是对底层 *数组* 的一个 *连续片段* 的引用。
    *   切片本身 *不存储* 数据，它只是一个 *描述符*，包含三个字段：
        *   `array`: 指向底层数组的指针。
        *   `len`: 切片的长度（元素个数）。
        *   `cap`: 切片的容量（从切片的起始位置到底层数组末尾的可用元素个数）。

    ```go
    type slice struct {
        array unsafe.Pointer // 指向底层数组的指针
        len   int            // 切片的长度
        cap   int            // 切片的容量
    }
    ```

2.  **切片的创建:**

    *   **字面量:** `s := []int{1, 2, 3}`
    *   **`make` 函数:** `s := make([]int, len, cap)`
        *   `len`: 初始长度。
        *   `cap`: 容量（可选，默认为 `len`）。
    *   **从数组或切片创建:** `s := arr[low:high]` 或 `s := otherSlice[low:high]`
        *   `low`: 起始索引（包含）。
        *   `high`: 结束索引（不包含）。
        *   省略 `low` 默认为 0。
        *   省略 `high` 默认为 `len(arr)` 或 `len(otherSlice)`。

3.  **切片的操作:**

    *   **访问元素:** `s[i]` (索引从 0 开始)
    *   **修改元素:** `s[i] = value`
    *   **切片表达式 (Slicing):** `s[low:high]` (创建新切片，但共享底层数组)
    *   **`append` 函数:** `s = append(s, element1, element2, ...)`
        *   如果容量足够，`append` 在底层数组的末尾添加新元素。
        *   如果容量不足，`append` 会分配一个新的、更大的底层数组，并将原切片中的元素和新元素复制到新数组中。
    *   **`copy` 函数:** `n := copy(dst, src)` (复制 `src` 中的元素到 `dst`，返回复制的元素个数)

4.  **扩容机制 (Go 1.18 及之后):**

    *   如果原切片容量小于 256，新容量通常是原来的 *2 倍*。
    *   如果原切片容量大于等于 256，新容量通常以 *约 1.25 倍* 的速率增长。
    *   实际分配的容量还会根据 *内存对齐* 进行调整。

5.  **切片作为函数参数:**

    *   切片的 *描述符*（包含指针、长度、容量的结构体）是 *按值传递* 的。
    *   在函数内部修改切片中的 *元素* 会影响到原始切片（因为它们共享底层数组）。
    *   在函数内部修改切片的 *长度或容量*（例如，`append` 导致扩容）*不会* 影响到原始切片。

6.  **`nil` 切片 vs. 空切片:**

    *   **`nil` 切片:** 没有底层数组，`len` 和 `cap` 都为 0，值为 `nil`。
    *   **空切片:** 有底层数组（长度为 0），`len` 和 `cap` 都为 0，值不为 `nil`。

7.  **内存泄漏:**

    *   从一个大的切片中截取一小部分，但原始大切片仍然被持有，导致大数组无法被垃圾回收。
    *   **避免方法：** 创建新的切片并将需要的数据复制到新切片中。
