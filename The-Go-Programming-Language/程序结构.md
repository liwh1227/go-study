**第二章“程序结构”要点总结：**

1.  **命名 (Naming):**

    *   Go 中标识符（变量、常量、类型、函数、包名等）的命名规则：以字母或下划线开头，后跟任意数量的字母、数字或下划线。
    *   区分大小写。
    *   25 个关键字（`break`, `default`, `func` 等）不能用作标识符。
    *   预声明的标识符（`int`, `true`, `make` 等）可以被重新声明，但通常不建议这样做。
    *   命名惯例：
        *   驼峰式命名 (camelCase 或 CamelCase)。
        *   包名通常使用小写单词，不用下划线或混合大小写。
        *   缩略词作为名称时，要么全大写 (如 `URL`、`HTTP`)，要么全小写 (如 `url`、`http`)，以保持一致性。
        *   局部变量名应简短，作用域越大，名称可以越长、越有描述性。
2.  **声明 (Declarations):**

    *   Go 中的四种主要声明：`var` (变量)、`const` (常量)、`type` (类型)、`func` (函数)。
    *   `var` 声明变量：
        *   可以显式指定类型，也可以让编译器根据初始值推断类型。
        *   可以一次声明多个变量。
        *   如果没有初始值，变量会被初始化为对应类型的零值（数值类型为 0，布尔类型为 false，字符串为空字符串，引用类型为 nil）。
        *   短变量声明 (`:=`)：只能在函数内部使用，用于声明和初始化局部变量，类型由初始值推断。
    *   `const` 声明常量：
        *   常量的值必须在编译期确定。
        *   可以是数值、布尔值或字符串。
        *   可以使用 `iota` 常量生成器来声明一组递增的常量。
    *   `type` 声明类型：
        *   可以定义新的命名类型（结构体、接口等）。
        *   可以为现有类型创建类型别名。
    *   `func` 声明函数。
3.  **变量 (Variables):**

    *   变量的生命周期：
        *   全局变量：与程序的生命周期相同。
        *   局部变量：从声明开始到不再被引用为止（可能在函数返回之前就结束）。
        *   形式参数和返回值：也是局部变量
    *   指针：
        *   指针存储了变量的内存地址。
        *   `&` 操作符获取变量的地址。
        *   `*` 操作符访问指针指向的变量。
        *   Go 没有指针运算。
        *  函数中可以安全返回局部变量指针.
    *   `new` 函数：
        *   `new(T)` 分配一个类型为 `T` 的零值，并返回指向它的指针 (`*T`)。
        *   `new` 返回的内存总是被初始化为零值。
    *   变量逃逸：
        *   如果一个局部变量的指针被返回或存储到全局变量中，那么这个变量就会“逃逸”到堆上。
        *   逃逸分析由编译器自动完成。
4.  **赋值 (Assignments):**

    *   `=` 普通赋值。
    *   `+=`、`-=`、`*=`、`/=`、`%=` 等复合赋值。
    *   多重赋值：允许同时给多个变量赋值 (例如 `x, y = y, x` 交换两个变量的值)。
    *   可赋值性：如果类型相同，或者底层类型相同且其中一个是未命名类型，或者实现了接口。
5.  **类型声明 (Type Declarations):**

    *   `type` 关键字用于定义新的命名类型。
    *   类型别名 (`type T1 = T2`)：`T1` 和 `T2` 是完全相同的类型，可以互换使用。
    *   定义新类型 (`type T1 T2`)：`T1` 是一个新类型，它与 `T2` 具有相同的底层类型，但它们是不同的类型。
6.  **包和文件 (Packages and Files):**

    *   Go 代码组织在包中。
    *   每个 `.go` 文件都属于一个包。
    *   `package` 声明位于文件的开头。
    *   `main` 包是程序的入口点。
    *   `import` 语句用于导入其他包。
    *   包的初始化：
        *   按照依赖关系顺序初始化包。
        *   先初始化包级别的变量，然后执行 `init()` 函数。
        *   每个包的 `init()` 函数只执行一次。
        *  `main` 包最后初始化, `main` 函数最后执行.
    *   匿名导入：使用 `_` 作为包的别名，只执行包的 `init()` 函数，而不导入包中的任何标识符。 常用于注册驱动或执行副作用.
7. **作用域 (Scope):**
    *   作用域控制着名称的可见性.
    *   块作用域: 由花括号`{}`包围, 比如if, for语句块.
    *   词法作用域: 静态作用域, 由代码结构决定, 而不是运行时决定.
    *   预声明标识符是全局作用域.
    *   包级别声明的标识符是包级作用域.
    *   函数参数和返回值是函数级作用域.
    *   内层作用域可以遮蔽外层作用域同名的标志符.

**测试题 (含面试常见问题)：**

**(一) 选择题 (每题 2 分，共 20 分)**

1.  以下哪个不是 Go 的关键字？
    A. `func`
    B. `var`
    C. `string`
    D. `break`

2.  关于 Go 中的命名，以下说法错误的是？
    A.  标识符可以以数字开头。
    B.  包名通常使用小写。
    C.  局部变量名应简短。
    D.  区分大小写。

3.  以下关于 `var` 声明的说法正确的是？
    A.  必须显式指定类型。
    B.  如果没有初始值，变量会被初始化为 `null`。
    C.  可以一次声明多个变量。
    D.  只能在函数内部使用。

4.  以下关于 `const` 声明的说法错误的是？
    A.  常量的值可以在运行时修改。
    B.  可以使用 `iota` 常量生成器。
    C.  可以是数值、布尔值或字符串。
    D. 常量必须在编译期确定。

5.  以下关于指针的说法正确的是？
    A.  Go 支持指针运算。
    B.  `*` 操作符用于获取变量的地址。
    C.  `&` 操作符用于访问指针指向的变量。
    D.  函数不能返回局部变量的指针。

6. 以下哪个不是 Go 预声明的标识符？
   A. `int`
   B. `true`
   C. `make`
   D. `package`

7.  以下关于 `new` 函数的说法错误的是？
    A.  `new(T)` 返回一个 `*T` 类型的值。
    B.  `new` 返回的内存总是被初始化为零值。
    C.  `new` 函数用于创建切片、map 和 channel。
    D. `new(T)` 分配类型为T的空间.

8.  以下关于包初始化的说法错误的是？
    A.  按照依赖关系顺序初始化包。
    B.  先执行 `init()` 函数，然后初始化包级别变量。
    C.  每个包的 `init()` 函数只执行一次。
    D. `main` 包最后初始化.

9.  以下关于短变量声明 (`:=`) 的说法错误的是？
    A.  只能在函数内部使用。
    B.  类型由初始值推断。
    C.  可以用于重新声明变量。
    D. 用于声明并初始化.

10. 以下关于类型别名的说法正确的是？
    A.  类型别名和原类型是不同的类型。
    B.  类型别名不能有自己的方法。
    C.  类型别名和原类型可以互换使用。
    D. 类型别名不能是指针类型.

**(二) 简答题 (每题 5 分，共 30 分)**

1.  请解释 Go 中的逃逸分析，并举例说明哪些情况会导致变量逃逸。
2.  `new` 和 `make` 有什么区别？分别用于什么场景？
3.  Go 中如何实现包的导入和初始化？`init()` 函数的作用是什么？
4. 什么是变量遮蔽? 举例说明.
5. 简述值类型和引用类型的区别，并举例说明Go中的值类型和引用类型。
6. `_` 在Go中有什么作用?

**(三) 编程题 (共 50 分)**

1.  (10 分) 编写一个 Go 程序，声明一个 `Person` 结构体，包含 `Name` (string) 和 `Age` (int) 字段。创建一个 `Person` 类型的变量，并使用两种不同的方式为其字段赋值（一种使用 `new`，一种使用字面量）。

2.  (15 分) 编写一个 Go 程序，演示 `iota` 常量生成器的用法。定义一组表示星期几的常量 (Sunday, Monday, ..., Saturday)，并打印它们的值。然后，定义一组表示文件权限的常量 (Read, Write, Execute)，并使用位运算来组合这些权限。

3. (10分) 编写一个Go程序，其中有两个包`a`和`b`，包`a`导入包`b`，包`b`中有一个`init()`函数打印一条消息。 在 `main` 包中，导入包 `a`，观察程序的输出，并解释输出的顺序。

4. (15分) 编写一个 Go 函数，交换两个 `int` 类型变量的值。要求使用指针实现，并且不能使用临时变量。在 `main` 函数中调用这个函数，并验证交换是否成功。

**答案及解析：**

**(一) 选择题**

1.  C ( `string` 是预声明的类型，不是关键字)
2.  A (标识符不能以数字开头)
3.  C (可以一次声明多个变量，类型可以推断，如果没有初始值，会初始化为零值，可以在包级别使用)
4.  A (常量的值必须在编译期确定，不能修改)
5.  D (可以返回局部变量指针, Go 会自动进行逃逸分析)
6.  D (`package` 是关键字，用于声明包)
7.  C (`new` 不用于创建切片、map 和 channel，`make` 才用于创建这些类型)
8.  B (先初始化包级别变量，然后执行 `init()` 函数)
9.  C (短变量声明不能用于重新声明变量，至少要有一个新的变量)
10. C (类型别名和原类型是完全相同的类型)

**(二) 简答题**

1.  **逃逸分析：** 编译器用来决定变量分配在栈上还是堆上的过程。如果一个局部变量的生命周期超出其声明所在的函数，或者被其他可能在函数返回后继续存在的对象引用，那么这个变量就会逃逸到堆上。
    **逃逸场景：**
    *   返回局部变量的指针。
    *   将局部变量的指针存储到全局变量或长生命周期对象中。
    *   将局部变量的指针传递给其他 goroutine。
    *   接口类型的变量（因为接口的底层数据可能在堆上）。
    *  切片, map, channel中的元素, 如果其类型是指针类型或者包含指针字段的类型.
    *   大的局部变量 (超过栈空间大小).

2.  **`new` 和 `make` 的区别：**
    *   `new(T)` 分配一个类型为 `T` 的零值，并返回指向它的指针 (`*T`)。主要用于分配基本类型和结构体的内存。
    *   `make(T, args)` 用于创建切片、map 和 channel，并返回一个类型为 `T` 的初始值（不是指针）。

3.  **包的导入和初始化：**
    *   使用 `import` 语句导入包。
    *   编译器根据依赖关系确定包的初始化顺序（拓扑排序）。
    *   先初始化包级别变量，然后按照声明顺序执行 `init()` 函数。
    *   每个包的 `init()` 函数只执行一次。
    *   `main` 包最后初始化，`main` 函数最后执行。
    *   `init()` 函数用于执行包级别的初始化任务，不能被显式调用，没有参数和返回值。

4. **变量遮蔽:** 变量遮蔽指的是, 在内层作用域中声明一个和外层作用域中同名的变量, 那么在这个内层作用域中, 外层作用域的同名变量将被隐藏(遮蔽).
    ```go
    package main

    import "fmt"
    var a = 10

    func main() {
        fmt.Println(a)  //10
        if true{
            a := 5
            fmt.Println(a) //5
        }
        fmt.Println(a) //10
    }
    ```
5. **值类型 vs 引用类型**
    * 值类型: 直接存储值, 变量直接表示实际的数据. 赋值或传递参数时, 会复制实际的数据. 修改副本不会影响到原始数据.
    * 引用类型: 存储的是内存地址. 变量表示的是指向底层数据的指针. 赋值或传递参数时, 复制的是指针(地址). 多个变量可以指向同一块内存数据.
    * Go中的值类型: 基本数据类型(int, float, bool, string), 数组, 结构体.
    * Go中的引用类型: 指针, 切片, map, channel, interface, 函数.
6. **`_`的作用**
    * 空白标识符, 用于忽略某个值. 比如, 函数返回多个值, 但只关心其中一部分返回值.
    * 匿名导入包, 仅执行包的`init()`函数, 而不导入包内的任何标识符.
    * 在接口实现中, 用于确保类型实现了接口的所有方法(编译期检查).
    ```go
    var _ io.Writer = (*MyWriter)(nil)
    ```

**(三) 编程题**

(略 - 提供思路，请自行实现)

1.  **`Person` 结构体：**
    *   使用 `type Person struct { ... }` 定义结构体。
    *   使用 `new(Person)` 创建一个 `*Person` 类型的变量，并通过 `.` 操作符访问字段并赋值。
    *   使用 `Person{Name: "...", Age: ...}` 字面量创建一个 `Person` 类型的变量。

2.  **`iota` 常量生成器