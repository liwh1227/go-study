**第六章 "方法" 关键内容总结**

1.  **方法声明与接收者 (Receiver)**

    *   **概念：** 方法是与特定类型关联的函数。这个特定类型被称为方法的接收者（receiver）。
    *   **语法：** `func (receiver Type) MethodName(parameters) (returnTypes) { ... }`
    *   **接收者类型：** 可以是任何类型（包括内置类型、结构体、自定义类型等），但不能是接口类型或指针类型（接收者本身可以是这两种类型的值）。
    *   **值接收者 vs. 指针接收者：**
        *   **值接收者：** 方法操作的是接收者值的副本。对副本的修改不会影响原始值。
        *   **指针接收者：** 方法操作的是接收者值的地址。可以通过指针修改原始值。使用指针接收者还可以避免大对象的复制开销。
    *   **匿名字段的方法：** 如果结构体中嵌入了匿名字段，可以访问匿名字段类型的方法，就像这些方法是直接定义在包含结构体上一样（方法提升）。

2.  **基于指针接收者的方法**

    *   **修改原始值：** 主要目的，通过指针间接修改接收者所指向的值。
    *   **避免复制：** 对于大型结构体，使用指针接收者可以避免复制整个结构体，提高效率。
    *   **`nil` 接收者：** 指针接收者方法可以处理接收者为 `nil` 的情况（只要在方法内部做了相应的检查）。
    *   **惯例：** 如果一个类型的任何方法有指针接收者，那么该类型的所有方法都应该使用指针接收者（即使有些方法不需要修改原始值）。

3.  **通过结构体内嵌组成类型**

    *   **嵌入：** 结构体可以嵌入其他类型（通常是结构体），从而获得被嵌入类型的字段和方法。
    *   **方法提升：** 可以直接通过外层结构体变量访问内嵌类型的方法，就像这些方法是直接定义在外层结构体上一样。
    *   **冲突解决：** 如果外层结构体和内嵌类型有同名字段或方法，优先访问外层结构体的成员。可以通过显式指定内嵌类型来访问其成员。
    *   **应用：** 模拟面向对象中的“继承”关系（实际上是组合），实现代码复用。

4.  **方法值和方法表达式**

    *   **方法值 (Method Value)：** 将方法绑定到特定的接收者上，形成一个可调用的值。
        ```go
        p := Point{1, 2}
        distanceFromP := p.Distance // 方法值，绑定了接收者 p
        fmt.Println(distanceFromP(Point{4, 6})) // 调用方法值
        ```
    *   **方法表达式 (Method Expression)：** 将方法看作一个普通的函数，其中接收者作为第一个参数。
        ```go
        p := Point{1, 2}
        distance := Point.Distance // 方法表达式
        fmt.Println(distance(p, Point{4, 6})) // 显式传递接收者
        ```

5.  **封装 (Encapsulation)**

    *   **概念：** 将数据（字段）和操作数据的方法（方法）绑定在一起，并控制对数据的访问。
    *   **Go 中的实现：**
        *   **大小写：** 首字母大写的标识符（类型、字段、方法等）是导出的（exported），可以在包外访问；首字母小写的标识符是非导出的（unexported），只能在包内访问。
        *   **方法：** 通过方法来访问和修改非导出的字段，实现对数据的封装和保护。
    *   **好处：**
        *   **数据隐藏：** 隐藏内部实现细节，只暴露必要的接口。
        *   **防止误用：** 通过控制访问权限，防止外部代码直接修改对象的状态，导致数据不一致。
        *   **提高可维护性：** 修改内部实现时，只要保持对外接口不变，就不会影响外部代码。

**面试常见问题**

1.  **什么是方法？它和函数有什么区别？**

    *   **回答要点：** 方法是与特定类型关联的函数，有接收者；函数是独立的代码块。方法可以访问接收者的字段和方法。

2.  **值接收者和指针接收者有什么区别？什么时候应该使用哪种？**

    *   **回答要点：** 值接收者操作副本，指针接收者操作原始值。需要修改原始值、避免复制大对象、处理 `nil` 接收者时，使用指针接收者。惯例上，如果一个类型有指针接收者方法，那么所有方法都应该使用指针接收者。

3.  **Go 中的方法可以重载吗？**

    *   **回答要点：** 不可以。Go 不支持方法重载（具有相同名称但不同参数的方法）。

4.  **什么是方法提升？它有什么作用？**

    *   **回答要点：** 结构体嵌入其他类型时，可以访问内嵌类型的方法，就像这些方法是直接定义在外层结构体上一样。作用是模拟继承，实现代码复用。

5.  **如何理解 Go 中的封装？Go 是如何实现封装的？**

    *   **回答要点：** 封装是将数据和操作数据的方法绑定在一起，并控制对数据的访问。Go 通过大小写标识符的导出/非导出特性，以及通过方法来访问非导出字段来实现封装。

6.  **什么是方法值和方法表达式？它们有什么区别和联系？**

    *   **回答要点：** 方法值是绑定了接收者的方法，可以直接调用；方法表达式是将方法看作普通函数，接收者作为第一个参数。

7.  **`nil` 接收者有什么用？举例说明。**

    *  **回答要点：** 允许在接收者为 `nil` 的情况下调用方法，可以在方法内部进行 `nil` 检查，避免 panic。
       例如：
     ```go
        type IntList *[]int

        func (list IntList) Sum() int {
          if list == nil { // 处理 nil 接收者
            return 0
          }
          sum := 0
          for _, v := range *list {
            sum += v
          }
          return sum
        }

        func main() {
          var list1 IntList // list1 为 nil
          fmt.Println(list1.Sum()) // 输出 0，不会 panic
          
          list2 := IntList(&[]int{1,2,3})
          fmt.Println(list2.Sum())
        }
     ```
8.  **给出一个代码示例，解释结构体内嵌以及方法提升。**
    ```go
    type Person struct {
        Name string
        Age  int
    }
    
    func (p Person) Greet() {
        fmt.Printf("Hi, I'm %s, %d years old.\n", p.Name, p.Age)
    }
    
    type Employee struct {
        Person // 匿名字段
        JobTitle string
    }

    func (e Employee) Introduce() {
       fmt.Printf("I work as a %s.\n", e.JobTitle)
    }    

    func main() {
        e := Employee{
            Person: Person{Name: "Alice", Age: 30},
            JobTitle: "Engineer",
        }
    
        e.Greet() // 方法提升，直接访问内嵌类型 Person 的 Greet 方法
        e.Introduce()
    }
    ```

**补充说明**

*   在准备面试时，除了掌握这些概念，还应该多做练习，编写一些示例代码，加深理解。
*   对于书中给出的示例代码，要仔细阅读，理解其背后的设计思想。
*  遇到`nil`接收者的问题，可以尝试从“空指针异常”和“默认值”的角度去思考。
